// M0: A
// M1: B LSB
// M2: B MSB
// M3: mask
// M4: result LSB
// M5: result MSB
// M6: counter
MOVI 1 , 2 // Put operant A into R1
MOVI 2 , 0xFFFF // Put operant B into R2
SW 1 , 0 , 0
SW 2 , 0 , 1
ADDI 3 , 0 , 1
SW 3 , 0 , 3

loopprim: LW 2 , 0 , 3 // Load mask
LW 1 , 0 , 0 // Load A into R1
NAND 3 , 1 , 2 // NAND of mask & A
MOVI 4 , 0xFFFF // AND between R1 & R2 == 00...0 if A. curBit == 0 => NAND == 11...1
BEQ 3 , 4 , notone

// If curBit == 1, do R = R + B (if curBit == 0, we do nothing)
LW 1 , 0 , 1 // B LSB in R1
LW 2 , 0 , 4 // R LSB in R2
ADDI 3 , 0 , 45 // Prepare the call to additionreport
JALR 7 , 3 // Jump with save of return address to R7

SW 3 , 0 , 4 // New result LSB from R3 stored in M4
LW 5 , 0 , 5 // Result MSB loaded in R5
ADD 5 , 4 , 5 // Add R4 (carry bit) & R5 in R5
LW 6 , 0 , 2 // Load B MSB to R6
ADD 5 , 5 , 6 // Add B MSB & result MSB
SW 5 , 0 , 5 // Save new R MSB in M5

// Do B = B + B
notone: LW 1 , 0 , 1 // B LSB in R1
LW 2 , 0 , 1 // B LSB in R2
ADDI 3 , 0 , 45 // Prepare the call to additionreport
JALR 7 , 3 // Jump with save of return address to R7

SW 3 , 0 , 1 // Save new B LSB to M1
LW 5 , 0 , 2 // Load B MSB to R5
ADD 5 , 5 , 5 // Add B MSB & B MSB and write to R5
ADD 5 , 4 , 5 // Add the carry bit if any
SW 5 , 0 , 2 // Save the new B MSB to M2

// End of B = B + B
// Load counter and increment
LW 1 , 0 , 6
ADDI 1 , 1 , 1

// Check if counter == 16
ADDI 2 , 0 , 16 // Load 16 into R2
BEQ 1 , 2 , writeres // If last bit, go to write result
// Else
SW 1 , 0 , 6 // Save counter
LW 1 , 0 , 3 // Load mask
ADD 1 , 1 , 1 // Mask x2
SW 1 , 0 , 3 // Save mask

BEQ 0 , 0 , loopprim // Unconditional jump to beginning of loop

writeres: LW 3 , 0 , 4 // Load result LSB into R3
LW 4 , 0 , 5 // Load result MSB into R4
halt

// Put the LSB of R1 + R2 in R3 with carry bit in R4
additionreport: nop
// R1: op 1
// R2: op 2
// R3: mask, then final result
// R4: report flag
// R5: temp 1, used for R1 NAND R3, loop verification, temporary serious science, final temp to check flag status
// R6: temp 2, temp 0xFFFF for serious science
addi 3 , 0 , 1 // Set the mask in R3, initialized at 1
nand 5 , 1 , 3 // NOT (R1 && R3) in R5
nand 6 , 2 , 3
beq 5 , 6 , flag // If equal, maybe set the flag, iff the result is not 0xFFFF
beq 0 , 0 , loop // If not equal, skip the operation setting the flag (label "flag") and go directly to the loop.
flag: movi 5 , 0xFFFF // Put 0xFFFF inside R5. R5 will act as a buffer (its content does not interest us anymore)
beq 5 , 6 , loop // If R6 (the result of R2 NAND mask, which was equal to R1 NAND mask) == 0xFFFF, no report needed.
add 4 , 3 , 3 // Set the mask at the mask + the mask (mask stored in R3). Flag.
loop: movi 5 , 0x4000 // Stores the constant to be checked.
beq 3 , 5 , finalop // Run the loop 14 times until mask is 0x4000.
add 3 , 3 , 3 // Shift the mask.
nand 5 , 1 , 3
nand 6 , 2 , 3
beq 5 , 6 , flagloop
nand 5 , 4 , 3 // If not equal proceed to some serious science. Temp (R5) = flag NAND mask
nand 5 , 5 , 3 // Temp = temp NAND mask
movi 6 , 0xFFFF
beq 5 , 6 , flagloop // If temp == 0xFFFF, set flag.
beq 0 , 0 , loop // If not equal, just ignore the flag and rerun.
flagloop: movi 5 , 0xFFFF
beq 5 , 6 , loop
add 4 , 3 , 3
beq 0 , 0 , loop

// Final operations
finalop: add 3 , 3 , 3 // Update mask
nand 5 , 1 , 3
nand 6 , 2 , 3
beq 5 , 6 , report
nand 5 , 4 , 3 // If not equal proceed to some serious science. Temp = flag NAND mask
nand 5 , 5 , 3 // Temp = temp NAND mask
movi 6 , 0xFFFF
beq 5 , 6 , report // If temp == 0xFFFF, report.
beq 0 , 0 , end
report: movi 5 , 0xFFFF
beq 5 , 6 , end
addi 4 , 0 , 1 // Carry bit.
end: add 3 , 1 , 2 // Addition
addi 5 , 0 , 1 // Set R5, temp, to check the flag
beq 5 , 4 , halt
addi 4 , 0 , 0 // If the msb of the flag array is not set, empty the array
beq 0 , 0 , halt
halt: JALR 0 , 7
